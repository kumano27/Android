## Chapter3 01 Androidアプリのコンポーネント  

### Androidアプリのエントリーポイント  

　多くのプログラミング言語では、アプリの起動時にmain()関数が呼ばれ、そこからすべての処理が開始する。  
これを __エントリーポイント__ という。  

　Androidアプリは、そのような単一の固定されたエントリーポイントを持っていない。  
その代わり複数のエントリーポイントを持つことが可能。  

　Androidアプリのアクティビティやサービスといった __コンポーネント__ は、それぞれがエントリーポイントとして振る舞うことが可能。  
このことであるアプリから別のアプリのコンポーネントを呼び出すことや、状況に応じてスタートする画面を変更するなどの柔軟な動作を可能にした。  
言い換えると1つのAndroidアプリは、複数の協力し合うコンポーネントで構成されている。  

　以下Androidアプリを構成する代表的なコンポーネント  


### アクティビティ  
　アプリの画面を表示するためのコンポーネント。  
状態の保存・復帰の為の仕組みや他のコンポーネントを呼び出す機能が用意されている。  

　それぞれのアクティビティには、ユーザーインターフェースなどを表示するためのウィンドウが1つ与えられる。  
他の多くのコンポーネント同様、ライフサイクルの各状態に応じたコールバックを受け取ることが可能。  

　アクティビティを含む各コンポーネントは、他のアクティビティやサービスなどのコンポーネントを呼び出すことが可能。  
この時、「どのような機能を使用したいか」「どのようなコンポーネントか」といったカテゴリー、その他情報をメッセージとしてシステムに伝達可能。  
この仕組みを __インテント(Intent)__という。  

　インテントには、どのアクティビティを呼び出したいかの指定や、インテントに設定したアクションやカテゴリーをもとに、適切なアクティビティをシステムに選定する事が可能。  
前者の事を __明示的インテント(Explicit Intent)__ 、後者のことを __暗黙的インテント(Implicit Intent)__ と呼ぶ。  

　インテントとは、日本語で意図・目的といった意味。何をしたいのか、どのようなコンポーネントを呼びたいのかといった意図をシステムに伝え、システムはその意図に合致するコンポーネントの中から、あらかじめ定められた方法によって、適切なものを選定して起動する。  
[](
明示的インテントと暗黙的インテントの違い\  
明示的 -> 同一アプリケーション内でのアクティビティ\  
暗黙的 -> コンポーネント名を指定する代わりに、「http://...なるURIを表示するアクティビティを起動せよ」というメッセージを送る \  
明示的 -> ローカル、自分のアプリ内のアクティビティを起動 \  
暗黙的 -> グローバル、画像(jpeg)を送信するアクティビティを起動\  
アクティビティ名を具体的に指定する場合 -> 明示的インテント\
表示したいデータと行いたいアクションを指定することによってシステムがアクティビティを選択する場合 -> 暗黙的インテント\
現状そこまで意識しなくてもよい\
)
 
 　アプリは自身を構成する各コンポーネントがどのようなインテントを受け取るかをマニフェストファイルに記述しておくことで、  
インストール時に受け取るインテントの種類がシステムに登録される。  

　
### フラグメント  
　アクティビティの持つユーザーインターフェイス(UI)や機能の一部を表現するもの。  
独立したライフサイクルを持ち、複数のアクティビティで再利用可能で、アクティビティの処理によって追加・削除する事が可能。  

　例えば、スマートフォン用にメールボックス表示、メール一覧表示、メール内容表示をそれぞれ1つの画面で背に表示するメールアプリがあったとする。  

　このメールアプリの画面レイアウトを、画面サイズが大きなタブレットにそのまま適用したら、表示要素が間延びして、使い勝手もよくないユーザーインターフェイスになりませんか？  
 
 　タブレットで利用するなら、メールボックス表示、メール一覧表示、メール内容表示のそれぞれの要素を、それぞれ1個のフラグメントとして扱うことで、画面サイズに合わせて表示を変更できる。  
  
  　フラグメントをつか合わないで、画面サイズに合わせてユーザーインターフェイスを変えようとすると、処理が複雑になるか、同じようなコードをあちこちに記述することになりがち。  
フラグメントを使うと、こうした処理を簡潔に記述できる。  

　まず、「メールボックスを表示するフラグメント」「メールの一覧を表示するフラグメント」「メール本文を表示するフラグメント」の各要素をそれぞれ作成する。  
その上でスマートフォンでは1画面に1個のフラグメントを、タブレットでは横に3つのフラグメントを並べて配置する処理を記述する。  
 
　アプリの規模が大きくなってくると、適切な単位で区切られた、互いに疎結合(システムの構成要素間の結びつきや互いの依存関係、関連性などが弱く、各々の独立性が高い状態のこと)な複数のアクティビティで構成した方が、コードの見通しが良くなる。  
 

### サービス  
　バックグラウンドで動作するコンポーネント。ユーザーインターフェイスの提供は行わない。  
長時間にわたる処理や、ユーザーが画面を離れても動作を続けて欲しい処理などに使用。  

　例えば、SNSに画像をアップロードしている間中、画面を開き続けてアップロードの完了を待たないといけないとしたら、ユーザーはうんざりしてしまう。  
このような場合は、アップロード処理はサービスにまかせて、ユーザーは他の操作が出来るようにしておくべき。  

　ユーザーの行動を阻害しない形で処理を行いたい場合や、アクティビティのライフサイクルに影響されずに処理を継続したい場合にサービスは活躍する。  
サービスもアクティビティと同様に、他のコンポーネントを呼び出したり、別のアプリにも公開して、使用してもらう事も可能。  

　サービスの実装には注意が必要。基本的にアプリと同一のプロセスのメインスレッド上で動作するため、CPUを酷使する処理をそのまま実装することは避け、  
サービス内でスレッドを立てた上で動作させるべき。Androidには、別スレッド上で非同期的に処理を行うための仕組みがいくつも用意されている。  


### コンテントプロバイダ  
　アプリが管理しているデータへのアクセスを提供するためのコンポーネント。  
データの管理には、SQLiteデータベースが使われる事が多い(もちろん他でも可)。  
テキストファイルや画像ファイルなどを管理しているデータの実態が何であるかを意識することなくデータを取得し、  
操作することを可能にするための共通のインターフェイスを提供する。  

　コンテントプロバイダを通して、他のアプリに対してデータを提供することもでき、こうしたデータの取得・更新に対するアクセス権限の設定も柔軟に行うことが出来る。  

 Android SDK には、最初からいくつかのコンテントプロバイダが用意されている。  
例えば、カメラで撮影した写真や、カレンダー情報、連絡先情報などを、コンテントプロバイダを通して取得・更新することが可能。  

　上記により、写真編集アプリを作る場合に、ユーザーがどのカメラアプリを使用しているか、そのアプリがどこに写真を保存しているかなどを意識する必要がなくなる。  


### ブロードキャストレシーバ  
　限定された機能を持つコンポーネント。ブロードキャストされたインデントを受け取り、処理を行う。  
 
 インデントのブロードキャストは、個別のアプリから行うことも可能。システムが発行するものも多くある。  
例えば、端末が充電器に接続された時、ネットワークの接続状態が変化した時、日付が変わった時、端末がスリープした時... などそれぞれのタイミングで特定のアクションを持ったブローキャストインデントが発行される。  

　ブロードキャストレシーバは、これらのインデントを受け取って、何らかの処理を行うことが可能。  
例えば、Wi-Fiに接続されたタイミングでデータの更新を行う、といった事。  
ただし、あまり複雑な処理を行うべきではない。  
ブロードキャストレシーバは、データ更新を行うサービスを呼ぶだけにしておき、データ更新そのものは呼び出したサービス側で行うべき。  

 というのも、ブロードキャストレシーバは、インデントを受け取ってからごく短い間に処理を終えなければ、ユーザーに対して強制終了を行うかどうかのダイアログを表示してしまうから。  
この時間は標準で10秒に設定されている。


　Androidの世界では、コンポーネントによってモジュラー化されたアプリが相互に連携することで、豊かなユーザー体験を創造する事が可能。  
一方で、積極的に外部アプリに提供するつもりのないコンポーネントについては、ユーザー保護の観点から明示的に利用を禁止すべき。  



## Chapter3 02 コンポーネントのライフサイクル  

### アクティビティのライフサイクル  
　他のコンポーネントと比べるとやや複雑。状態が変化するごとに、Activityクラスのコールバックメソッドが呼ばれる。  
開発者は、このコールバックメソッドに、それぞれの状態に対応した処理を追加することが可能。  
例えば、アクティビティが停止した時にリソースを解放する。  

　下図はアクティビティの状態と、各タイミングで呼ばれるコールバックメソッドを示したもの(一部のみ)。  
アクティビティが呼び出された後、ユーザーが操作可能になるまでの間に、すぐにいくつものコールバックメソッドが呼ばれている。  

[](Bundle? -> Kotlinの書き方)
#### > onCreate(Bundle?)  
　アクティビティが最初に起動されたときに呼ばれる。レイアウトの作成さど、最初に1回だけ実行される初期処理はここで行う。  
Bundle?型の引数が渡されるが、これはonSaveInstanceState()メソッドで保持された情報。  
onSaveInstanceState()が呼ばれていない場合はnullが渡される。  

#### > onStart  
　アクティビティが表示される直前であることを示す。onCleate()と異なり、アクティビティのライフサイクルの中で、繰り返し呼ばれる可能性がある。  
 
#### > onRestoreInstanceState(Bundle?)  
　onSaveInstanceState()メソッドで保存しておいた情報をもとに、画面の状態を復元するために呼ばれる。必ず呼ばれるわけではないので注意。  
　画面を回転させた場合や、このアクティビティが非表示の間にメモリが必要になって、プロセスごと終了した場合など、何らかの事情でこのアクティビティを再初期化する場合のみ呼ばれる。  
　onSaveInstanceState()メソッドで保存しておいた情報は、onCreate()でも渡されるので、必ずしもここで復元する必要はない。  
 
#### > onResume()  
　アクティビティがユーザーの操作を受け付けるようになる直前で呼ばれる。  
カメラのような、排他的アクセス制御がされているハードウェアへのアクセスを開始したり、onPause()で退避しておいたデータを復元する際に使用。  

#### > onPause()  
　アクティビティがバックグランドに移行する直前で呼ばれる。onResume()っとセットにして使われることが多く、カメラなどのハードウェアへのアクセスや、大きなリソースを開放するのにつかわれる。  
 あるアクティビティAから、別のアクティビティBを呼び出す場合、アクティビティAのonPause()が完了するまでは、アクティビティBは作成されない。  
そのため、ここで長時間かかる処理を行うことは避けるべき。  

　この状態になると、メモリが足りなくなった場合などに、onStop()やonDestroy()を経由することなくプロセスを終了させられる可能性が出て来る。  
 その為、どうしても破棄されると困る情報は、永続化しておく必要がある。  


#### > onSaveInstanceState(Bundle?)  
　アクティビティの状態に関する情報を保持しておくために呼ばれる。  
onRestoreInstanceState()と同様、必ず呼ばれるわけではない。テキストフィールドに入力した文字など、ユーザーインターフェイスに関する情報は、デフォルトで保存されるため、わざわざ実装する必要が無い。また、onStop()より先に呼ばれるが、onPause()との呼ばれる順序に関しては保証されていない。  

#### > onStop()
　アクティビティがユーザーからまったく見えなくなった後に呼ばれる。onPause()でメモリが不足したなどの理由でプロセスを終了させられた場合、onStop()は呼ばれない。  
 
#### > onRestart()  
　onStop()の後、アクティビティが再度表示される場合に呼ばれる。  

#### > onDestroy()  
　アクティビティが破棄される直前に呼ばれる。メモリが不足したといった理由でプロセスを終了させられた場合などには、呼ばれない可能性がある。  

　アクティビティがバックグランドにある場合、いつプロセスが終了するか分からない。  
そのため必ず